#' Bounding box generator
#' 
#' Swiss army knife for bounding boxes. Modify an existing bounding box or create a new bounding box from scratch. See details.
#' 
#' An existing bounding box (defined by \code{x}) can be modified as follows:
#' \itemize{
#' \item Using the extension factor \code{ext}.
#' \item Changing the width and height with \code{width} and \code{height}. The argument \code{relavitve} determines whether relative or absolute values are used. 
#' \item Setting the x and y limits. The argument \code{relavitve} determines whether relative or absolute values are used.}
#' 
#' A new bounding box can be created from scratch as follows:
#' \itemize{
#' \item Using the extension factor \code{ext}.
#' \item Setting the center coorinates \code{cx} and \code{cy}, together with the \code{width} and \code{height}.
#' \item Setting the x and y limits \code{xlim} and \code{ylim}
#' }
#' 
#' @param x One of the following:
#' \itemize{
#' \item A shape (from class \code{\link[sp:Spatial]{Spatial}} or \code{\link[raster:Raster-class]{Raster}})
#' \item A bounding box (either 2 by 2 matrix or an \code{\link[raster:Extent]{Extent}} object). 
#' \item Open Street Map search query. The bounding is automatically generated by querying \code{q} from Open Street Map Nominatim. See \url{http://wiki.openstreetmap.org/wiki/Nominatim}.}
#' If \code{x} is not specified, a bounding box can be created from scratch (see details.
#' @param ext Extension factor of the bounding box. If 1, the bounding box is unchanged. Values smaller than 1 reduces the bounding box, and values larger than 1 enlarges the bounding box. This argument is a shortcut for both \code{width} and \code{height} with \code{relative=TRUE}. If a negative value is specified, then the shortest side of the bounding box (so width or height) is extended with \code{ext}, and the longest side is extended with the same absolute value. This is especially useful for bounding boxes with very low or high aspect ratios.
#' @param cx center x coordinate
#' @param cy center y coordinate
#' @param width width of the bounding box. These are either absolute or relative (depending on the argument \code{relative}).
#' @param height height of the bounding box. These are either absolute or relative (depending on the argument \code{relative}).
#' @param xlim limits of the x-axis. These are either absolute or relative (depending on the argument \code{relative}).
#' @param ylim limits of the y-axis. See \code{xlim}.
#' @param relative boolean that determines whether relative values are used for \code{width}, \code{height}, \code{xlim} and \code{ylim} or absolute. If \code{x} is unspecified, \code{relative} is set to \code{"FALSE"}.
#' @param current.projection projection string (see \code{\link{set_projection}}) of the that corresponds to the 
#' @param projection projection string (see \code{\link{set_projection}}) to transform the bounding box to.
#' @import sp
#' @importFrom raster extent
#' @importFrom XML xmlTreeParse xmlChildren xmlRoot xmlAttrs
#' @importFrom rgeos gIntersection
#' @example ../examples/bb.R
#' @export
bb <- function(x=NA, ext=NULL, cx=NULL, cy=NULL, width=NULL, height=NULL, xlim=NULL, ylim=NULL, relative = FALSE, current.projection=NULL, projection=NULL) {
	if (is.character(x)) {
		q <- gsub(" ", "+", x, fixed = TRUE)
		addr <- paste0("http://nominatim.openstreetmap.org/search?q=", q, "&format=xml&polygon=0&addressdetails=0")

		tmpfile <- tempfile()
		suppressWarnings(download.file(addr, destfile = tmpfile, mode= "wb", quiet = TRUE))
		
		doc <- xmlTreeParse(tmpfile)
		unlink(tmpfile)
		if (length(xmlChildren(xmlRoot(doc)))==0) stop(paste("No results found for \"", x, "\".", sep=""))
		first_search_result <- xmlChildren(xmlRoot(doc))[[1]]
		bbx <- xmlAttrs(first_search_result)["boundingbox"]
		cy <- as.numeric(xmlAttrs(first_search_result)["lat"])
		cx <- as.numeric(xmlAttrs(first_search_result)["lon"])
		b <- matrix(as.numeric(unlist(strsplit(bbx, ","))), ncol=2, byrow=TRUE)[2:1,]
	} else if (inherits(x, "Extent")) {
		b <- bbox(x)		
	} else if (inherits(x, c("Spatial", "Raster"))) {
		b <- bbox(x)	
		current.projection <- proj4string(x)
	} else if (is.matrix(x) && length(x)==4) {
		b <- x
	} else if (is.vector(x) && length(x)==4) {
		b <- matrix(x, ncol=2, byrow=TRUE)
	} else if (!is.na(x)[1]) {
		stop("Incorrect x argument")	
	} else {
		if ((missing(xlim) && (missing(width) || missing(cx))) || (missing(xlim) && (missing(height) || missing(cy)))) 
			stop("Argument x is missing. Please specify x, or {xlim and ylim}, or {width, height, cx, and cy}.")
		## create new bounding box
		if (missing(xlim)) xlim <- cx + c(-.5, .5) * width
		if (missing(ylim)) ylim <- cy + c(-.5, .5) * height
		b <- matrix(c(xlim, ylim), ncol=2,nrow=2, byrow = TRUE)
	}
	
	if (!is.character(x)) {
		if (missing(cx)) cx <- mean(b[1,])
		if (missing(cy)) cy <- mean(b[2,])
	}

	steps <- b[, 2] - b[, 1]
	
	if (!missing(ext)) {
		relative <- TRUE
		if (ext > 0) { 
			width <- ext
			height <- ext
		} else {
			if (steps[1] > steps[2]) {
				height <- -ext
				width <- 1 + (-ext-1) * (steps[2]/ steps[1])
			} else {
				width <- -ext
				height <- 1 + (-ext-1) * (steps[1]/ steps[2])
			}
		}
	}
	
	if (relative) {
		xlim <- if (!is.null(xlim)) {
			b[1,1] + xlim * steps[1]
		} else if (!is.null(width)) {
			c(cx - (width/2) * steps[1],
			  cx + (width/2) * steps[1])
		} else {
			b[1, ]
		}
		ylim <- if (!is.null(ylim)) {
			b[2,1] + ylim * steps[2]
		} else if (!is.null(height)) {
			c(cy - (height/2) * steps[2],
			  cy + (height/2) * steps[2])
		} else {
			b[2, ]
		}
	} else {
		if (!is.null(width)) {
			xlim <- c(cx - (width/2),
					  cx + (width/2))
		} else if (is.null(xlim)) {
			xlim <- b[1, ]
		}
		if (!is.null(height)) {
			ylim <- c(cy - (height/2),
					  cy + (height/2))
		} else if (is.null(ylim)) {
			ylim <- b[2, ]
		}
	}
	b <- matrix(c(xlim, ylim), ncol = 2, byrow=TRUE, 
		   dimnames=list(c("x", "y"), c("min", "max")))
	
	if (!missing(projection)) {
		if (is.null(current.projection)) {
			if (!maybe_longlat(b)) {
				stop("Current projection unknown. Please specify the projection.")
			}
			warning("Current projection unknown. Long lat coordinates (wgs84) assumed.")
			current.projection <- "longlat"	
		} 
		
		
		errorFound  <- TRUE
		opt <- options(warn=-1, verbose=FALSE)
		log <- capture.output({
		iter <- 1
		while(errorFound) {
			sp_poly <- as(extent(b), "SpatialPolygons")
			world_end <- end_of_the_world(proj=current.projection)
			
			sp_poly2 <- tryCatch({
				gIntersection(sp_poly, world_end)
			}, error=function(e){
				sp_poly
			})
			if (is.null(sp_poly2)) sp_poly2 <- sp_poly
			
			co <- sp_poly2@polygons[[1]]@Polygons[[1]]@coords
			
			# add intermediate points
			co2 <- apply(co, 2, function(v) {
				n <- length(v)
				c(v[1], rep(v[-n], each=4) + as.vector(sapply((v[-1] - v[-n]) / 4, function(w)cumsum(rep(w,4)))))
			})
			
			sp_pnts <- SpatialPoints(co2, proj4string = CRS(get_proj4(current.projection)))
			
			errorFound  <- FALSE
			tryCatch({
				sp_pnts2_prj <- set_projection(sp_pnts, projection=projection)
			}, error=function(e) {
				assign("b", bb(b, ext=.99), envir = parent.env(environment()))
				assign("errorFound", TRUE, envir = parent.env(environment()))
				NULL
			})
			cat("test\n")
			if (iter==100) stop("Something went wrong with the bounding box. Please check the projection.") else iter <- iter + 1
		}
		})

		do.call("options", opt)
		
		#sp_rect_prj <- set_projection(sp_rect, projection=projection)
		#sp_rect_prj <- set_projection(sp_rect, current.projection = current.projection, projection=projection)
		#sp_rect_prj <- spTransform(sp_rect, CRSobj = get_proj4(projection))
		b <- sp_pnts2_prj@bbox
	}
	
	b	
}
